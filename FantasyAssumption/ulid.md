# ULID (Universal Lexicographic Unique Identifier) 技术文档  
**——基于 512 位原生数据与 128 字符编码的增强型标识符**

---

## 一、概述

**ULID（Universal Lexicographic Unique Identifier）** 是一种新型的高信息密度全局唯一标识符，通过 **512 位原生数据结构** 和 **128 字符定长编码** 实现双重严格性约束。ULID 在保留时间有序性、用户可编程性的基础上，新增 **高容量元数据层** 和 **抗量子计算哈希摘要**，适用于对安全性和信息密度要求极高的场景。其核心特性包括：

- **严格定长**：原生数据 **512 位**，编码后 **128 字符**（Base62），无信息冗余。
- **时空可追溯**：支持解析毫秒级生成时间、用户自定义字段及扩展元数据。
- **抗碰撞设计**：原生数据经哈希摘要和随机数双重加固，碰撞概率低于 `1e-40`。
- **量子安全**：可选抗量子哈希算法（如 SHA3-512）保护原生数据完整性。

---

## 二、核心设计目标

1. **信息超密度存储**：在 512 位原生数据中嵌入时间戳、用户数据、系统随机数、元数据四层信息。
2. **编码严格性**：原生数据与编码结果长度强制锁定（512 位 → 128 字符），拒绝动态伸缩。
3. **元数据开放可读**：通过专用工具解析生成时间、用户标识、安全等级等开放字段。
4. **抗熵衰减**：原生数据哈希摘要 + 系统随机数，抵御时间戳回拨和随机数熵不足风险。

---

## 三、原生数据结构（512 位）

ULID 的 **512 位原生数据** 分为五个部分，实现多层次信息融合：

| 字段名称           | 位数   | 描述                                                                 |
|--------------------|--------|----------------------------------------------------------------------|
| **时间戳**         | 128 位 | 纳秒级 Unix 时间戳（可表示至公元 362,790 年）                       |
| **用户数据**       | 256 位 | 用户自定义内容（如业务标识、加密哈希、地理编码）                     |
| **系统随机数**     | 64 位  | 加密安全随机数（CSPRNG 生成）                                       |
| **元数据**         | 32 位  | 开放字段（版本号、哈希算法标识、安全等级） + 保留位                  |
| **哈希摘要**       | 32 位  | 前 480 位数据的抗碰撞哈希（如 CRC32、BLAKE3），用于快速校验完整性    |

---

## 四、编码规则：Base62 超密度压缩

### 1. 编码流程
1. **原生数据分组**：将 512 位数据分割为 **10 个 51 位组** + **1 个 2 位填充组**（末尾补零）。
2. **Base62 转换**：每个 51 位组转换为 9 字符（因 `62^9 ≈ 2^53.3` 覆盖 51 位空间），总长度 `10×9 + 2=92` 字符。
3. **长度对齐**：填充固定随机串至 **128 字符**，填充内容不参与解码。

### 2. 编码示例
```
原生数据（512 bit）:  
0x1f4a3d8c...（共 64 字节）  

Base62 编码:  
2Kp9QhNz7mFvLjW8cR1XgH...（92 有效字符 + 36 填充字符 = 128 字符）
```

---

## 五、生成与解析流程

### 1. 生成算法
```plaintext
                     +-----------------+
                     | 用户数据 (256b) |
                     +-----------------+
                            ↓
+------------+       +------------+      +-----------------+
| 时间戳     |  → →  | 哈希摘要   |  → → | 系统随机数      |
| (128b)     |       | (32b)      |      | (64b)           |
+------------+       +------------+      +-----------------+
                            ↓
                     +------------+
                     | 元数据     |
                     | (32b)      |
                     +------------+
                            ↓
                     +--------------------+
                     | 512 位原生数据     |
                     +--------------------+
                            ↓
                     [Base62 超密度编码]
                            ↓
                     +--------------------+
                     | 128 字符 ULID     |
                     +--------------------+
```

### 2. 解析工具示例
```bash
$ ulid-tool decode 2Kp9QhNz7mFvLjW8cR1XgH...（128 字符）

{
  "timestamp": "2024-03-15T12:34:56.789123456Z",  # 纳秒级时间
  "user_data": "0x8a3d...",                       # 用户自定义内容（Hex 或自定义格式）
  "metadata": {
    "version": 3,                                  # ULID 规范版本
    "hash_algorithm": "BLAKE3",                   # 哈希算法标识
    "security_level": "L5"                        # 安全等级（L1-L5）
  },
  "checksum_valid": true                          # 哈希摘要校验结果
}
```

---

## 六、唯一性与安全性

### 1. 碰撞概率计算
- **时间戳粒度**：纳秒级（1e9 唯一值/秒）
- **随机数空间**：系统随机数 2^64 + 用户数据 2^256 ≈ 2^320
- **哈希摘要**：32 位碰撞检测（辅助校验）
- **综合碰撞概率**：同一纳秒内碰撞概率低于 `1/(2^320) ≈ 1e-96`

### 2. 抗攻击设计
- **量子安全**：用户数据可存储抗量子哈希（如 SHA3-512）。
- **熵增强**：系统随机数混合硬件熵（如 RDRAND、TPM 模块）。
- **反解码混淆**：填充字符使用伪随机生成，防止暴力拆解原生数据。

---

## 七、与传统方案对比

| 特性               | ULID (512→128)         | UUIDv4               | 加密哈希（SHA256）   |
|--------------------|------------------------|----------------------|---------------------|
| 原生数据容量       | 512 位                 | 128 位               | 可变长度            |
| 编码定长           | ✅ 128 字符            | ✅ 36 字符           | ❌ 可变长度         |
| 用户数据嵌入       | ✅ 256 位              | ❌                    | ❌                  |
| 时间可追溯         | ✅ 纳秒级              | ❌                    | ❌                  |
| 抗量子安全         | ✅ 可选                | ❌                    | ✅（部分算法）      |

---

## 八、应用场景

1. **区块链**：作为交易 ID，存储合约哈希和多方签名信息。
2. **基因工程**：存储基因片段哈希与实验时序数据。
3. **金融合规**：审计追踪 ID 含交易双方哈希和监管元数据。

---

## 九、注意事项

1. **用户数据规范**：建议对 256 位用户数据定义子结构（如前 128 位为业务 ID，后 128 位为扩展字段）。
2. **填充安全性**：禁用全零或可预测模式填充，需用 CSPRNG 生成填充字符。
3. **工具链依赖**：编解码需依赖标准化工具库，避免自行实现导致数据截断错误。

---

## 十、参考实现（Python 伪代码）

```python
import time
import os
import base62
from hashlib import blake2b

def generate_ulid(user_data: bytes, metadata: int) -> str:
    # 1. 时间戳（128 位，纳秒）
    timestamp_ns = int(time.time() * 1e9).to_bytes(16, 'big')
    
    # 2. 计算哈希摘要（BLAKE3，32 位）
    hash_digest = blake2b(timestamp_ns + user_data, digest_size=4).digest()
    
    # 3. 系统随机数（64 位）
    sys_rand = os.urandom(8)
    
    # 4. 元数据（32 位）
    metadata_bytes = metadata.to_bytes(4, 'big')
    
    # 5. 构建原生数据（512 位）
    raw_data = timestamp_ns + user_data + sys_rand + metadata_bytes + hash_digest
    
    # 6. Base62 编码（512 位 → 128 字符）
    encoded = base62.encodebytes(raw_data).ljust(128, '0')[:128]
    return encoded
```

---

## 十一、总结

ULID 通过 **512 位原生数据** 和 **128 字符编码** 的刚性映射，实现了信息密度、安全性和可追溯性的三重突破。其超长原生数据空间支持深度业务定制，而固定编码长度避免了传统方案的存储冗余问题，成为高安全、高复杂度场景下的新一代标识符标准。